

## 1、介绍一下Innodb存储引擎

![image-20240313142653413](E:\My_Files\4_C++专业资料\Docs\image-20240313142653413.png)

共分为四个部分：

①Buffer Pool：缓冲池。作用：**用来缓存表数据和索引**数据，为了减少磁盘I/O操作，提升效率

②Change Buffer：写缓冲区。作用：**针对二级索引页（辅助索引）的更新优化措施**

③Log Buffer：日志缓冲区。作用：**（1）用来保存写入磁盘上的log文件（redo、undo）的数据；（2）用来优化每次更新操作都要写入redo Log 产生的磁盘I/O**。日志缓冲区内容会定期刷新到磁盘Log文件中

④Adaptive Hash Index：自适应Hash索引。作用：InnoDB不智齿手动创建Hash索引，但是它会进行自调优。判断如果建立了自适应Hash索引能够提升查询效率，则会在内存中建立相关的Hash索引，不需要人工干预。Innodb会根据自己的需求去创建Hash索引。

## 2、Buffer Pool 具体是什么？

![image-20240313145314998](E:\My_Files\4_C++专业资料\Docs\image-20240313145314998.png)

Buffer Pool：缓冲池。用来缓存表数据和表索引数据的，减少磁盘I/O

Buffe Pool 有**缓存数据页（Page）**和对缓存数据页进行描述的**控制块**组成。

（1）缓存数据页（Page）：Innodb 存储引擎以 页 为单位对数据进行划分，以页作为磁盘和内存监护的基本单位。默认页大小（16KB）。

Buffe Pool 除了缓存了索引页和数据页，还有undo页，自适应哈希索引、插入缓存页、锁信息等。

（2）控制块：控制块中存储着对应的缓存页所属的表空间信息，数据页编号，控制块所对应的缓存页在Buffe Pool 中的地址信息。

（3）Buffe Pool 默认大小为128M，以Page（16KB）为单位，控制块一般为Page的5%大小大约800字节。

**如何判断一个数据也是否在Buffe Pool 中？**

​	MySQL中有一个Hash表结构，在该结构中以“**表空间号+数据页编号**” 作为KEY值；以“**缓存页对应的控制块**”作为VALUE值。当需要访问某个页的数据时，先从Hash表中根据 表空间号+数据页编号 查看是否存在对应的缓存页，如果有，则直接使用；如果没有，则从free链表里面拿出来一个空闲缓存页，把磁盘中对应的页加载到该缓存页的位置。

## 3、在Buffe Pool 中如何管理Page页？

Page页分类：在Buffe Pool底层采用链表管理Page。Page根据状态分为三种类型：

1）free Page：空闲Page，未被使用的；

2）clean Page：被使用的Page，但是数据没有被修改过；

3）dirty Page：脏页，被使用过的Page，并且数据被更改过，缓存也中的数据和磁盘数据不一致，需要后期写入磁盘中；

上面三种Page类型，Innodb采用三种不同的链表结构进行维护和管理。

1）==free list（双向链表）==：把所有的空闲缓存页对应的控制块作为节点放在==free list（双向链表）==中。

![image-20240313151509369](E:\My_Files\4_C++专业资料\Docs\image-20240313151509369.png)

磁盘加载页的流程：

> ①从free list中取出一个空闲的控制块（对应缓存页）
>
> ②把该缓存页对应的控制块信息填上
>
> ③把缓存页对应的free 链表节点从链表中删除。

2）==flush list（双向链表）== ：该链表表示需要刷新到磁盘缓冲区，**==管理脏页==**。内部Page按照修改时间排序。

由后台线程负责每隔一段时间把脏页刷新到磁盘中。

![image-20240313152224170](E:\My_Files\4_C++专业资料\Docs\image-20240313152224170.png)

3）==lru list==。表示正在使用的缓冲区，**管理 clean Page和dirty Page**，该缓冲区以 midpoint为基点，前面的链表称为 new 列表区，存放经常使用的数据（站63%）；后面的链表称为 old 列表区，存放不经常访问的数据（占37%）

注意：dirty Page在flush list 和 lru list里面都存在，但是两者互不影响。lru list负责管理Page 的可用性和释放；flush list负责管理dirty Page 的刷盘操作

## 4、MySQL中为什么没有采用传统的LRU算法？

**==普通的LRU算法==**：采用**最近最少使用**原则，末位淘汰。新数据需要从链表头部加入，释放空间时从链表末尾释放。

![image-20240313153528066](E:\My_Files\4_C++专业资料\Docs\image-20240313153528066.png)

普通的LRU算法缺点：

① **Buffer Pool 污染问题**：当某一个SQL扫描了大量数据时，就有可能把Buffer Pool中的所有页都替换出去，导致大量的人数据被淘汰了，当这些热数据再次被访问时，就会产生大量磁盘I/O，性能会降低。

![image-20240313155350635](E:\My_Files\4_C++专业资料\Docs\image-20240313155350635.png)

② 预读失效问题：MySQL中存在预读机制，很多预读的也会被放在LRU链表头部，如果没有使用到预读页，就会导致很多尾部的缓存页被淘汰，这就是预读失效。



## 5、MySQL中对于LRU算法进行了那些优化？

改进型PRU算法：**链表分为 new & old区，**加入元素时，从midpoint位置插入（即冷数据头部）

![image-20240313202354703](E:\My_Files\4_C++专业资料\Docs\image-20240313202354703.png)

冷数据区的数据页什么时候被转到热数据区？

1）如果数据页在PRU链表中存在时间超过1s，就将其移动到链表头部（链表指的是整个PRU链表）；

2）如果数据页在LRU链表中存在时间小于1s，位置不变了；

3）只有同时满足【被访问】和【在old区域停留不超过1s】，才会被插入到热数据区头部；这样就解决了Buffer Pool 污染问题

## 6、介绍一下Change Buffer

Change Buffer：写缓冲区，是针对二级索引页的更新优化措施

主要作用：在进行DML操作时，如果请求的是二级索引（辅助索引）并且没有在缓冲池中，此时，并不会立刻加载到缓冲池，而是在Change Buffer中记录缓冲变更，等待未来数据被读取的时候，再将数据合并恢复到Buffer Pool.

![image-20240313213547351](E:\My_Files\4_C++专业资料\Docs\image-20240313213547351.png)

Change Buffer 占用了Buffer Pool空间，默认占用25%，最大允许占用50%。（这个根据具体业务量而定）

应用场景：对于写多读少的场景，页面在写完之后马上被访问的效率比较小，这时候在使用Change Buffer效果最好。



### 什么情况下进行Merge？

1）访问这个数据页会触发Merge

2）系统有后台线程，定期Merge

3）在数据库正常关闭过程中，回执行Merge

![image-20240313214033849](E:\My_Files\4_C++专业资料\Docs\image-20240313214033849.png)

### ==Change Buffer 更新流程==

![image-20240313214210909](E:\My_Files\4_C++专业资料\Docs\image-20240313214210909.png)

**写缓冲区，仅适用于非唯一二级索引页，为什么?**

如果索引设置了唯一性，在进行修改时，InnoDB就必须要做唯一性校验，因此必须查询磁盘，做一次I0操作。
会直接将记录查询到Buffer Pool中，然后在缓冲池中修改，不会在Change Buffer 中操作。

## 7、Log Buffer 作用？

Log Buffer：是日志缓冲区。**用来保存要写入磁盘上的log（redo ,undo）文件的数据。**Log Buffer定期进行刷盘

Log Buffer作用：用来优化每次更新操作后都要写入redo log而产生的磁盘I/O过多问题。【Log Buffer满是自动刷盘，当遇到BLOB或者更新语句多的大事务时，增加Log Buffer可以节省磁盘I/O】

![image-20240313215045329](E:\My_Files\4_C++专业资料\Docs\image-20240313215045329.png)



## 8、Innodb是否支持Hash索引？

1）不支持：**指不支持用户手动创建Hash索引**，使用存储引擎默认的值进行替代（B+ Tree）。

2）支持：InnoDB 进行自调优，如果判断建立AHI，能够提高查询效率，InnoDB就会在内存中建立相关的哈希索引。不需要人工干预。

**为什么要有自适应哈希索引 AHI?**

AHI用于实现对于热数据页的一次查询。使用**聚族索引**进行数据页的定位的时候，需要根据索引树的高度，从根节点走到叶子结点，通常是需要3~4次查询才能定位数据。InnoDB会根据对索引的使用情况和索引字段进行分析，通过自调优的方式为索引页建立哈希索引。

## 9、自适应Hash索引（AHI）是如何提高查询效率的？

AHI所作用的目标是频繁查询的数据页和作索引页，由于数据页是聚簇索引的一部分，因此AHI是建立在索引之上的索引。

对于二级索引，如果命中AHI，则直接从AHI中获取二级索引的记录指针，在根据主键沿着聚簇索引查数据；

对于聚簇索引，如果聚簇索引查询命中AHL，则直接返回目标数据页的指针，此时就可以根据记录指针直接定位 数据页。

![image-20240313222008112](E:\My_Files\4_C++专业资料\Docs\image-20240313222008112.png)

![image-20240313222018878](E:\My_Files\4_C++专业资料\Docs\image-20240313222018878.png)

![image-20240313222028777](E:\My_Files\4_C++专业资料\Docs\image-20240313222028777.png)

## 10、说一下Innodb的磁盘结构中表空间的作用

![image-20240313223337266](E:\My_Files\4_C++专业资料\Docs\image-20240313223337266.png)

表空间：Innodb物理存储中的最后高层

### （1）系统表空间

是一个共享的表空间，该空间的数据文件默认是 IBDATA1.

在设置了系统表空间自动增长后，是不可缩减的，即使删除系统表空间中存储的表和索引，也不会缩减其在磁盘中的大小。（默认大小12M）

**数据字典**：包含表结构，数据库名/表名，字段类型，视图，索引，表字段信息，mysql版本等信息。

**双写缓冲区**：y哦那个与保证写入磁盘时页数据的完整性，防止写失效问题。

**修改缓冲区**：内存中ChangeBuffer对应的持久化区域，为了保证数据完整性。

**回滚日志（Undo log）**：记录数据修改前的状态，逻辑日志。主要用来实现事务回滚，实现MVCC

### （2）独立表空间

每个表都有自己的独立表空间，并且每个表的数据和索引都存在自己的表空间中。

作用：可以实现单表在不同数据库中的移动。表空间可以回收（再执行删除或者清空操作后，会还给操作系统）

### （3）通用表空间

与系统表空间类似，是共享的，可以存储多个表数据。（比独立表空间消耗的内存少，占有磁盘空间小）

### （4）回滚表空间

用来保存回滚日志。undo log默认保存在系统表空间的ibdata1文件中。

参数innodb_undo_tablespace =0 表示不开启独立表空间，1表示开启。

#### 什么时候需要开启undo 表空间？

由于系统表空间不会自动缩减，当出现大事务时，undo log 会不断增大，当ibdata1文件写满时，MySQL8.0之后对Undo进行了分离，默认会产生两个undo表空间文件，进行动态的扩缩容。

### （5）临时表空间

用于存储用户创建的临时表和磁盘内部的临时表。MySQL5.7之后采用独立的临时表空间，命名为 ibtmp1 文件，初始大小12M，默认无上限。



## 11、什么是写失效？如何解决的？

写失效：

Linux文件系统页（OS Page）默认大小是4KB，MySQL数据页默认大小是16KB。在写入磁盘是需要分为4次。

如果存储引擎正在写盘时发生了宕机，如果此时只写了一部分页，叫做写失效，会导致数据丢失。并且这种无法靠redo log恢复

解决：**双写缓冲区**

![image-20240314104114321](E:\My_Files\4_C++专业资料\Docs\image-20240314104114321.png)

双写缓冲区为Innodb存储引擎提供了数据页的可靠性。

1）内存结构：Doublewrite Buffer，内存结构是由126个页构成的，大小是2MB

2）磁盘结构：Doublewrite Buffer磁盘结构实在系统表空间上的，共128个页，大小为2MB

**==数据双写流程：==**

在Buffer Pool 的Page页刷盘前，会将数据存储在Doublewrite 缓冲区。这样如果出现宕机重启情况，数据页被损坏了，那么就会在应用redo log 之前需要通过该页的副本还原该数据页，然后再进行redo log重做，Double write 实现了Innodb引擎数据页的可靠性。

![image-20240314104423132](E:\My_Files\4_C++专业资料\Docs\image-20240314104423132.png)



![image-20240314111253390](E:\My_Files\4_C++专业资料\Docs\image-20240314111253390.png)

## 12、介绍一下事务特性

==A：原子性==（事务作为整体，要么全执行，要么全失败）

==C：一致性==（事务应该确保数据库的状态从一个一致性的状态，转变为另一个一致性的状态）

==I：隔离性==（事务执行期间不被其他事务干扰，一个事务内部的操作以及使用的数据，对其他并发事务是隔离的）

==D：持久性==（事务一旦提交，他对数据库中做的改动是永久的，后续操作不应该对其有任何的影响，数据不会丢失）



Innodb有两种事务日志：

​	**==Redo log：重做日志==**。用于保证事务持久性

​	**==Undo log：回滚日志==**。用于保证事务的原子性和隔离性

![image-20240314112614219](E:\My_Files\4_C++专业资料\Docs\image-20240314112614219.png)



### MySQL持久性的保证，依赖于两个文件

​	1)Redo log  	2）binlog

Update执行流程：

![image-20240314151303714](E:\My_Files\4_C++专业资料\Docs\image-20240314151303714.png)

redo log 写入分为两步：①prepare ②commit ,就是两阶段提交（2PC）

![image-20240314153515887](E:\My_Files\4_C++专业资料\Docs\image-20240314153515887.png)



**为什么要有2PC?**

MySQL使用两阶段提交，主要是为了解决binlog 和 redo log的一致性问题 。当进行崩溃恢复时，redo log和binlog都有一个共同的数据字段 XID。

在进行崩溃恢复时，会顺序扫描redo log:

①如果碰到既有prepare又有commit的 redo log ，直接提交

②如果redo log 处于prepare 阶段，就会用XID去binlog中找对应的事物，判断事务所对应的binlog是不是完整的。

​	是，则直接提交；

​	否，则事务回滚

## 13、介绍一下Redo log，作用是什么？

**==WAL机制==**：（write ahead load）预写式日志。也就是先写日志，再写磁盘。**这样做既能提高性能，又可以保证数据的安全性**。MySQL中的redo log采用的就是WAL机制实现的。

==WAL机制既能提高性能，又能保证数据安全原因==：磁盘写是随机I/O，比较消耗性能；而每次将更新操作先写入日志，此时就变成了顺序写操作，实际的更新操作由后台线程根据log异步写入。WAL机制核心就是将随机写转换为顺序写，降低客户端延时。

**==Redo log基本概念==**：重做日志，是Innodb特有的事务日志，**用来保证事务的原子性和持久性**。redo log 是物理日志，记录的是对磁盘上的数据进行修改的相关信息。

Redo Log包括两部分：（1）内存中的日志缓冲:redo log buffer （2）磁盘上的日志文件：redolog file 

**==Redo Log作用==**：MySQL每执行一条DML语句，就会将记录写入到redolog buffer中。后续某个时间点再一次性将多个操作记录到redolog file。当故障发生导致内存数据丢失后，Innodb会在重启时，经过重复redo，。将数据恢复到崩溃之前的状态。

### redo log日志格式

==（1）物理日志==：记录每一页具体存储的值是多少，在这个数据页上做了啥修改？（eg：某个事务将系统表空间中第100个页中偏移量1000处，呢个字节的值由1变为2）

==（2）逻辑日志==：记录的是每一个Page页面中的具体数据是怎么变动的，记录的是一个变动的过程或者说记录的就是SQL语句的逻辑。

![image-20240314183400920](E:\My_Files\4_C++专业资料\Docs\image-20240314183400920.png)

## 14、事务还没提交的时候，redo log 能不能被持久化到磁盘？

==redo log持久化==：缓冲区的数据一般情况下是无法直接写入磁盘中的，中间必须要经过OS的缓冲区，再通过系统调用fsync()将其刷到磁盘。

redo log Buffer 持久化到redo log 可选的策略有三种（参数：Innodb_fulsh_log_at_trx_commit）

1）==0：延迟写==：该模式速度最快，但是不安全。MySQL进程的崩毁会导致上一面中所有的事务数据丢失。

2）==1：实时写，实时刷（默认值）==：该模式最安全，但速度最慢。

3）==2：实时写，延时刷==：该模式比较快，相比于0，相对安全。

![image-20240314184717777](E:\My_Files\4_C++专业资料\Docs\image-20240314184717777.png)

redo log 三种状态：

1）存在于redolog buffer中 ；2）向磁盘写入，但是还没有真正落盘，而是保存在OD Buffer中； 3）持久化到磁盘中

==触发真正的fsync场景：==

场景1：redolog buffer 占用的空间即将达到Innodb_log_buffer_size（默认值8M）一半的时候，后台线程会主动写盘

场景2：Innodb_fulsh_log_at_trx_commit = 1时，并行事务提交的时候，顺带将某个未提交的事物 redolog buffer 持久化到磁盘。因为redo log buffer 是共享的。

**==事务还没提交的时候，redo log 有可能会被持久化到磁盘，例如场景2==**





## 15、MySQL中脏页落盘的机制

在修改数据页时，首先修改缓冲池中的页，然后再以一定的频率刷新到磁盘中。脏页从缓冲池刷到从盘的操作并不是在每次更新的时候就触发，而是通过==checkout point 机制==刷新回磁盘。

**redo log可能会出现的问题**

（1）缓冲池不是无限大的，也就是说不能够一直存储数据而不刷盘；

（2）redo log 是循环使用的，满了怎么办？

（3）如果长时间运行了数据库，然后发生宕机，此时重新应用redo log，会非常耗时，回复成本会很高。

### ==checkout point 机制==

#### （1）缓冲池不够用时，将脏页刷到磁盘中

当缓冲池空间不够时，Innodb会采用PRU算法进行页淘汰，如果这个被释放的页是脏页，就需要强制执行checkout point，将脏页刷新到磁盘中。

#### （2）缩短数据库恢复时间

当数据库宕机时，数据库不需要重做所有日志，因为checkout point之前的页都是已经刷新回到磁盘中了，所以就只需要针对checkout point 后的redo log进行重做就行，减少恢复时间。

#### （3）redo log不够用时，将脏页刷盘

Innodb是以环形的方式写入数据到redo log中的：

![image-20240314203546369](E:\My_Files\4_C++专业资料\Docs\image-20240314203546369.png)

**write pos** ：表示当前日志记录的位置，当 ib_logfile_4日志写满后，会从 ib_logfile_1 继续写入

**==checkout point==**：表示日志记录的修改写进磁盘，完成数据落盘。落盘后checkout point会将日志上的相关记录擦除。即：

> ​		write pos ---> checkout point之间的部分是redo log 空闲的部分，用于继续记录。
>
> ​		checkout point---> write pos之间是redo log 待罗盘的数据修改记录。

### **总结**

checkout point 所做的事情就是将缓冲池中的脏页进行刷盘。每次刷新多少页，从那里取脏页，以及什么时候触发checkout point，均是由checkout point机制决定。

Checkpoint分为两种:

> **（1）sharp checkpoint:强制落盘**。把内存中所有的脏页都执行落盘操作。只有当关闭数据库之前才会执行。
>
> **（2）Fuzzy checkpoint:模糊落盘**。把一部分脏页执行落盘操作，又分为四种。
>
> ​		1) Master Thrad Checkpoint:==主线程定时将脏页写入磁盘，每秒或每10s执行一次脏页==
>
> ​		2) FLUSH_LRU_LIST :==buffer pool有脏页换出，执行落盘==
>
> ​		3) Async/Sync Flush checkpoint:当redo log快写满的时候执行落盘。
>
> ​				a.当redo log超过75%小于90%会执行异步落盘。
>
> ​				b.当redo log超过90%，会执行同步落盘操作。会阻塞写操作。
>
> ​		4) Dirty Page too much checkpoint:如果buffer pool中脏页太多，脏页率超过75%执行落盘

















